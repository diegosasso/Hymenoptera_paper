---
title: "Make Neff statistics per each replicate"
date: "`r Sys.Date()`"
output: 
  html_document:
    df_print: paged
---


Compute \(N_{\text{eff}}\) statistics for each stochastic-map replicate, summarize results with the mean and 95% confidence interval (2.5â€“97.5% quantiles) across 15 body regions, and save the output to: `data_out/neff-per-replicate.RDS`

```{r setup, include=F}

library(ape)
library(phytools)
library(ontophylo)
library(dplyr)
library(parallel)
library(viridis)
library(ggplot2)
library(abind)
library(dplyr)
library(purrr)
library(tidyr)
source("R/utils-ST.R")
source('R/region_class.R')


knitr::opts_chunk$set(
  echo = TRUE,       # show code by default
  warning = FALSE,
  message = FALSE
)
```


# Read data

```{r}

# read replicates
tree <-readRDS("data/hym_tree.RDS")
rates.multi <- readRDS("data_out/br_rates_all.RDS")

class(rates.multi)
length(rates.multi)
dim(rates.multi$cranium)

# read mean rates
rates <-readRDS("data_out/br_rates_all_ind.RDS")
rates <- do.call(cbind,rates)
# drop larva
rates <- rates[,-16]
class(rates)
dim(rates)
```

# Reshape as list of 1000 tables 152 x 15

```{r}
# names of body regions
regions <- names(rates.multi)
n_reps  <- ncol(rates.multi[[1]])   # 1000
n_branches <- nrow(rates.multi[[1]]) # 152

# build new list: one element per replicate
replicate_list <- lapply(1:n_reps, function(j) {
  # extract column j from each body region and bind
  mat <- sapply(rates.multi, function(region_mat) region_mat[, j])
  # ensure it's a matrix with rows = branches, cols = body regions
  mat <- matrix(mat, nrow = n_branches, ncol = length(regions))
  colnames(mat) <- regions
  mat
})

# drop larva
replicate_list <- lapply(replicate_list, function(x) x[, -16, drop = FALSE])

# check dims
length(replicate_list)   # 1000
dim(replicate_list[[1]]) # 152 x 15

# check if rates.multi==rates
col_means <- Reduce("+", replicate_list) / length(replicate_list)
diff <- col_means-rates
max(abs(diff))
```

# Calculate Neff for each replicate

May take a while

```{r}
n_eff_list <- map(replicate_list, function(mat) {
  enr <- get_enrichment_mask(mat, lower_q = 0.05, upper_q = 0.95,
                             direction = "over", return_type = "binary")
  out <- plot_enrichment_entropy(tree, enr, type = "Neff_scaled",
                                 n_points = 1000)$data
  out
})

n_eff_df <- bind_rows(n_eff_list, .id = "replicate")
head(n_eff_df)
```


# Reshape (per replicate Neff as list)

```{r}
# # eps is chosen to be a few orders of magnitude smaller than the smallest nonzero value observed, e.g.:
# eps <- min(n_eff_df$entropy[n_eff_df$entropy > 0]) * 1e-3
# 
# summary_df <- n_eff_df %>%
#   group_by(time) %>%
#   summarise(
#     mean_entropy = mean(entropy, na.rm = TRUE),
#     lower = quantile(entropy, 0.025, na.rm = TRUE),
#     median = quantile(entropy, 0.5, na.rm = TRUE),
#     upper = quantile(entropy, 0.975, na.rm = TRUE),
#     #
#     mean_f_plus= mean(prop_enriched, na.rm = TRUE),
#     f_plus_lower = quantile(prop_enriched, 0.025, na.rm = TRUE),
#     f_plus_upper = quantile(prop_enriched, 0.975, na.rm = TRUE),
#     #
#     log_mean_entropy = mean(log(entropy+eps), na.rm = TRUE),
#     log_f_plus
#   )
# head(summary_df)


# pick epsilon safely
eps <- min(n_eff_df$entropy[n_eff_df$entropy > 0], na.rm = TRUE) * 1e-3

summary_df <- n_eff_df %>%
  group_by(time) %>%
  summarise(
    # --- Neff / entropy summary ---
    mean_entropy = mean(entropy, na.rm = TRUE),
    lower_entropy = quantile(entropy, 0.025, na.rm = TRUE),
    median_entropy = quantile(entropy, 0.5, na.rm = TRUE),
    upper_entropy = quantile(entropy, 0.975, na.rm = TRUE),

    # --- f+ summary ---
    mean_f_plus = mean(prop_enriched, na.rm = TRUE),
    lower_f_plus = quantile(prop_enriched, 0.025, na.rm = TRUE),
    upper_f_plus = quantile(prop_enriched, 0.975, na.rm = TRUE),
    
    # --- H+ ---
    mean_H_plus = mean(H_plus, na.rm = TRUE),
    lower_H_plus = quantile(H_plus, 0.025, na.rm = TRUE),
    upper_H_plus = quantile(H_plus, 0.975, na.rm = TRUE),

    # --- log-transformed versions (for variance & contribution decomposition) ---
    mean_log_Neff = mean(log(entropy + eps), na.rm = TRUE),
    mean_log_f_plus = mean(log(prop_enriched + eps), na.rm = TRUE),

    var_log_Neff = var(log(entropy + eps), na.rm = TRUE),
    var_log_f_plus = var(log(prop_enriched + eps), na.rm = TRUE),
    var_H = var(H_plus, na.rm = TRUE),
    cov_logf_H = cov(log(prop_enriched + eps), H_plus, use = "pairwise.complete.obs")
  ) %>%
  # --- compute contributions ---
  mutate(
    C_f = var_log_f_plus / var_log_Neff,
    C_H = var_H / var_log_Neff,
    C_cov = 2 * cov_logf_H / var_log_Neff
  )

head(summary_df)
```

# Save

```{r}
saveRDS(summary_df, file='data_out/neff-per-replicate.RDS')
```



# Plot median with empirical 95% confidence interval

Alternatively: quantile interval or uncertainty interval

```{r}
ggplot() +
  geom_ribbon(data = summary_df, aes(x = time, ymin = lower, ymax = upper),
              fill = "blue", alpha = 0.2) +
  scale_x_reverse(breaks = seq(0, 280, by = 50)) +
  geom_line(data = summary_df, aes(x = time, y = median),
            color = "black", size = 1) +
  theme_minimal()
```
# Plot mean with empirical 95% confidence interval

```{r}
ggplot() +
  geom_ribbon(data = summary_df, aes(x = time, ymin = lower, ymax = upper),
              fill = "blue", alpha = 0.2) +
  scale_x_reverse(breaks = seq(0, 280, by = 50)) +
  geom_line(data = summary_df, aes(x = time, y = mean_entropy),
            color = "black", size = 1) +
  theme_minimal()
```

# Plot proportion of enriched states

```{r}
#summary_df <- read_rds('data_out/neff-per-replicate.RDS')

ggplot() +
  geom_ribbon(data = summary_df, aes(x = time, ymin = prop_enriched_lower, ymax = prop_enriched_upper),
              fill = "red", alpha = 0.4) +
  scale_x_reverse(breaks = seq(0, 280, by = 50)) +
  geom_line(data = summary_df, aes(x = time, y = mean_prop_enriched),
            color = "red", size = 1) +
  theme_minimal()
```

# Plot proportion of enriched vs Mean

```{r}
X <- 4

ggplot() +
  geom_ribbon(data = summary_df, aes(x = time, ymin = lower, ymax = upper),
              fill = "blue", alpha = 0.2) +
  scale_x_reverse(breaks = seq(0, 280, by = 50)) +
  geom_line(data = summary_df, aes(x = time, y = mean_entropy),
            color = "black", size = 1) +
  #
    geom_ribbon(data = summary_df, aes(x = time, ymin = prop_enriched_lower *X, ymax = prop_enriched_upper*X),
              fill = "red", alpha = 0.4) +
  geom_line(data = summary_df, aes(x = time, y = mean_prop_enriched*X),
            color = "red", size = 1) +
  theme_minimal()
```

# Contributions of factors over time

```{r}

summary_df %>%
  select(time, C_f, C_H, C_cov) %>%
  pivot_longer(cols = starts_with("C_"), names_to = "component", values_to = "contribution") %>%
  ggplot(aes(x = time, y = contribution, fill = component)) +
  geom_area(alpha = 0.6) +
  scale_x_reverse() +
  labs(x = "Time (Ma)", y = "Relative contribution") +
  theme_classic()
```


# Overall contribution

```{r}
eps <- min(n_eff_df$entropy[n_eff_df$entropy > 0], na.rm = TRUE) * 1e-3

overall_contrib <- n_eff_df %>%
  summarise(
    var_log_Neff = var(log(entropy + eps), na.rm = TRUE),
    var_log_f    = var(log(prop_enriched + eps), na.rm = TRUE),
    var_H        = var(H_plus, na.rm = TRUE),
    cov_fH       = cov(log(prop_enriched + eps), H_plus, use = "pairwise.complete.obs")
  ) %>%
  mutate(
    C_f   = var_log_f / var_log_Neff,
    C_H   = var_H / var_log_Neff,
    C_cov = 2 * cov_fH / var_log_Neff
  )

overall_contrib
```
```{r}
weighted_contrib <- summary_df %>%
  summarise(
    C_f   = weighted.mean(C_f, var_log_Neff, na.rm = TRUE),
    C_H   = weighted.mean(C_H, var_log_Neff, na.rm = TRUE),
    C_cov = weighted.mean(C_cov, var_log_Neff, na.rm = TRUE)
  )

weighted_contrib
```



