---
title: "Make Rate thru Time using Branch-specific rates"
date: "`r Sys.Date()`"
output: 
  html_document:
    df_print: paged
---


```{r setup, include=F}

library(ape)
library(phytools)
library(ontophylo)
library(dplyr)
library(parallel)
library(viridis)
library(ggplot2)
library(abind)
library(dplyr)
library(purrr)
source("R/utils-ST.R")
source('R/region_class.R')


knitr::opts_chunk$set(
  echo = TRUE,       # show code by default
  warning = FALSE,
  message = FALSE
)
```



## Read data

```{r}

# read replicates
tree <-readRDS("data/hym_tree.RDS")
rates.multi <- readRDS("data_out/br_rates_all.RDS")

class(rates.multi)
length(rates.multi)
dim(rates.multi$cranium)

```

## Reshape as list of 1000 tables 152 x 15

```{r}
# names of body regions
regions <- names(rates.multi)
n_reps  <- ncol(rates.multi[[1]])   # 1000
n_branches <- nrow(rates.multi[[1]]) # 152

# build new list: one element per replicate
replicate_list <- lapply(1:n_reps, function(j) {
  # extract column j from each body region and bind
  mat <- sapply(rates.multi, function(region_mat) region_mat[, j])
  # ensure it's a matrix with rows = branches, cols = body regions
  mat <- matrix(mat, nrow = n_branches, ncol = length(regions))
  colnames(mat) <- regions
  mat
})

# drop larva
replicate_list <- lapply(replicate_list, function(x) x[, -16, drop = FALSE])

# check dims
length(replicate_list)   # 1000
dim(replicate_list[[1]]) # 152 x 15
```

## Make rates

```{r}
rates_time <- branch_rate_thru_time_Multi(tree, replicate_list, n_points = 1000, time_points = NULL)
head(rates_time)

#plot(rates_time$time, rates_time$mean, type = 'l', xlim=c(280,0))
#plot(rates_time$time, rates_time$upper, type = 'l', xlim=c(280,0))
```

## Save

```{r}
saveRDS(rates_time, file='data_out/rates-thru-time.RDS')
```



## Plot mean with empirical 95% confidence interval

```{r}
p <- ggplot() +
  geom_ribbon(data = rates_time, aes(x = time, ymin = lower, ymax = upper),
              fill = "blue", alpha = 0.2) +
  scale_x_reverse(breaks = seq(0, 280, by = 50)) +
  geom_line(data = rates_time, aes(x = time, y = mean),
            color = "black", size = .3) +
  theme_minimal()

p
ggsave("figures/rate-thru-time/rate-thru-time.pdf", p, width = 3.5*2, height = 1.6*2, dpi = 300, units = "in")
```


## Plot median with empirical 95% confidence interval

```{r}
ggplot() +
  geom_ribbon(data = rates_time, aes(x = time, ymin = lower, ymax = upper),
              fill = "blue", alpha = 0.2) +
  scale_x_reverse(breaks = seq(0, 280, by = 50)) +
  geom_line(data = rates_time, aes(x = time, y = median),
            color = "black", size = .3) +
  theme_minimal()
```


## Rate and Se: corr

```{r}
rates_time <- readRDS('data_out/rates-thru-time.RDS')
Se <- readRDS('data_out/s-per-replicate.RDS')
head(rates_time)
head(rates_time)
```
```{r}
#idx <- seq(1, nrow(rates_thru_time), by = 20)

df <- tibble(
  time = rates_time$time,
  rate = rates_time$mean,
  se = Se$mean_s
)
```

```{r}
plot(df$rate, df$se)
cor.test(df$rate, df$se, method = 'pearson')
```

```{r}
rates_unique <- rates_time %>%
  arrange(time) %>%                                 # ensure time is increasing
  mutate(mean_prev = lag(mean)) %>%                 # compare with previous
  filter(is.na(mean_prev) | mean != mean_prev) %>%  # keep only when mean changes
  select(time, mean)  


nrow(rates_unique)
plot(rates_unique$time, rates_unique$mean)
```



```{r}
library(mgcv)



# Compute autocorrelation of both series
acf_rate <- acf(df$rate, plot = FALSE)$acf[2]
acf_se <- acf(df$se, plot = FALSE)$acf[2]
rho <- mean(c(acf_rate, acf_se), na.rm = TRUE)

# Effective number of independent samples (Pyper & Peterman 1998)
n <- nrow(df)
n_eff <- n * (1 - rho) / (1 + rho)

# Pearson correlation (absolute values)
r <- cor(df$rate, df$se, use = "pairwise.complete.obs")
t_val <- r * sqrt((n_eff - 2) / (1 - r^2))
p_val <- 2 * pt(-abs(t_val), df = n_eff - 2)

cat("r =", round(r,3), "n_eff =", round(n_eff,2), "p =", signif(p_val,3), "\n")
```


